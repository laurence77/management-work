const { google } = require('googleapis');
const { createClient } = require('@supabase/supabase-js');

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_KEY
);

class CalendarService {
  constructor() {
    this.oauth2Client = new google.auth.OAuth2(
      process.env.GOOGLE_CLIENT_ID,
      process.env.GOOGLE_CLIENT_SECRET,
      process.env.GOOGLE_REDIRECT_URI
    );
    
    this.calendar = google.calendar({ version: 'v3', auth: this.oauth2Client });
  }

  // Generate OAuth URL for calendar authorization
  generateAuthUrl(userId, scopes = ['https://www.googleapis.com/auth/calendar']) {
    const authUrl = this.oauth2Client.generateAuthUrl({
      access_type: 'offline',
      scope: scopes,
      state: userId, // Pass user ID in state for callback handling
      prompt: 'consent'
    });
    
    return authUrl;
  }

  // Exchange authorization code for tokens
  async exchangeCodeForTokens(code, userId) {
    try {
      const { tokens } = await this.oauth2Client.getAccessToken(code);
      
      // Store tokens in database
      await this.storeUserTokens(userId, tokens);
      
      return tokens;
    } catch (error) {
      console.error('Error exchanging code for tokens:', error);
      throw new Error('Failed to authorize calendar access');
    }
  }

  // Store user calendar tokens
  async storeUserTokens(userId, tokens) {
    const { error } = await supabase
      .from('user_calendar_tokens')
      .upsert({
        user_id: userId,
        access_token: tokens.access_token,
        refresh_token: tokens.refresh_token,
        token_type: tokens.token_type,
        expires_at: new Date(Date.now() + (tokens.expiry_date || 3600000)),
        scope: tokens.scope,
        updated_at: new Date()
      });

    if (error) {
      console.error('Error storing calendar tokens:', error);
      throw new Error('Failed to store calendar credentials');
    }
  }

  // Get user calendar tokens
  async getUserTokens(userId) {
    const { data, error } = await supabase
      .from('user_calendar_tokens')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (error) {
      console.error('Error fetching user tokens:', error);
      return null;
    }

    return data;
  }

  // Refresh expired tokens
  async refreshUserTokens(userId) {
    const tokens = await this.getUserTokens(userId);
    if (!tokens || !tokens.refresh_token) {
      throw new Error('No refresh token available');
    }

    this.oauth2Client.setCredentials({
      refresh_token: tokens.refresh_token
    });

    try {
      const { credentials } = await this.oauth2Client.refreshAccessToken();
      await this.storeUserTokens(userId, credentials);
      return credentials;
    } catch (error) {
      console.error('Error refreshing tokens:', error);
      throw new Error('Failed to refresh calendar access');
    }
  }

  // Set user credentials for API calls
  async setUserCredentials(userId) {
    let tokens = await this.getUserTokens(userId);
    
    if (!tokens) {
      throw new Error('User has not authorized calendar access');
    }

    // Check if token is expired
    if (new Date() >= new Date(tokens.expires_at)) {
      tokens = await this.refreshUserTokens(userId);
    }

    this.oauth2Client.setCredentials({
      access_token: tokens.access_token,
      refresh_token: tokens.refresh_token,
      token_type: tokens.token_type,
      expiry_date: new Date(tokens.expires_at).getTime()
    });
  }

  // Create calendar event for booking
  async createBookingEvent(userId, bookingData) {
    try {
      await this.setUserCredentials(userId);

      const event = {
        summary: `Booking: ${bookingData.celebrity_name}`,
        description: `
Celebrity Booking Event
  
Celebrity: ${bookingData.celebrity_name}
Event Type: ${bookingData.event_type}
Venue: ${bookingData.venue || 'TBD'}
Status: ${bookingData.status}
Budget: $${bookingData.budget?.toLocaleString() || 'TBD'}

Contact: ${bookingData.client_email}
Booking ID: ${bookingData.id}

Generated by Celebrity Booking Admin
        `.trim(),
        start: {
          dateTime: new Date(bookingData.event_date).toISOString(),
          timeZone: bookingData.timezone || 'America/New_York'
        },
        end: {
          dateTime: new Date(new Date(bookingData.event_date).getTime() + (2 * 60 * 60 * 1000)).toISOString(), // 2 hours duration
          timeZone: bookingData.timezone || 'America/New_York'
        },
        location: bookingData.venue,
        attendees: [
          { email: bookingData.client_email, displayName: bookingData.client_name },
          ...(bookingData.celebrity_contact_email ? [{ email: bookingData.celebrity_contact_email }] : [])
        ],
        reminders: {
          useDefault: false,
          overrides: [
            { method: 'email', minutes: 24 * 60 }, // 1 day before
            { method: 'popup', minutes: 60 }, // 1 hour before
            { method: 'email', minutes: 60 } // 1 hour before
          ]
        },
        colorId: '11', // Red color for bookings
        extendedProperties: {
          private: {
            bookingId: bookingData.id.toString(),
            source: 'celebrity-booking-admin'
          }
        }
      };

      const response = await this.calendar.events.insert({
        calendarId: 'primary',
        resource: event,
        sendUpdates: 'all'
      });

      // Store calendar event ID in booking record
      await supabase
        .from('bookings')
        .update({ calendar_event_id: response.data.id })
        .eq('id', bookingData.id);

      return response.data;
    } catch (error) {
      console.error('Error creating calendar event:', error);
      throw new Error('Failed to create calendar event');
    }
  }

  // Update calendar event when booking changes
  async updateBookingEvent(userId, bookingData) {
    try {
      if (!bookingData.calendar_event_id) {
        // Create new event if doesn't exist
        return await this.createBookingEvent(userId, bookingData);
      }

      await this.setUserCredentials(userId);

      const event = {
        summary: `Booking: ${bookingData.celebrity_name} - ${bookingData.status}`,
        description: `
Celebrity Booking Event (Updated)
  
Celebrity: ${bookingData.celebrity_name}
Event Type: ${bookingData.event_type}
Venue: ${bookingData.venue || 'TBD'}
Status: ${bookingData.status}
Budget: $${bookingData.budget?.toLocaleString() || 'TBD'}

Contact: ${bookingData.client_email}
Booking ID: ${bookingData.id}

Last Updated: ${new Date().toLocaleString()}
Generated by Celebrity Booking Admin
        `.trim(),
        start: {
          dateTime: new Date(bookingData.event_date).toISOString(),
          timeZone: bookingData.timezone || 'America/New_York'
        },
        end: {
          dateTime: new Date(new Date(bookingData.event_date).getTime() + (2 * 60 * 60 * 1000)).toISOString(),
          timeZone: bookingData.timezone || 'America/New_York'
        },
        location: bookingData.venue,
        attendees: [
          { email: bookingData.client_email, displayName: bookingData.client_name },
          ...(bookingData.celebrity_contact_email ? [{ email: bookingData.celebrity_contact_email }] : [])
        ]
      };

      const response = await this.calendar.events.update({
        calendarId: 'primary',
        eventId: bookingData.calendar_event_id,
        resource: event,
        sendUpdates: 'all'
      });

      return response.data;
    } catch (error) {
      console.error('Error updating calendar event:', error);
      throw new Error('Failed to update calendar event');
    }
  }

  // Delete calendar event when booking is cancelled
  async deleteBookingEvent(userId, bookingData) {
    try {
      if (!bookingData.calendar_event_id) {
        return; // No event to delete
      }

      await this.setUserCredentials(userId);

      await this.calendar.events.delete({
        calendarId: 'primary',
        eventId: bookingData.calendar_event_id,
        sendUpdates: 'all'
      });

      // Remove calendar event ID from booking record
      await supabase
        .from('bookings')
        .update({ calendar_event_id: null })
        .eq('id', bookingData.id);

    } catch (error) {
      console.error('Error deleting calendar event:', error);
      throw new Error('Failed to delete calendar event');
    }
  }

  // Get user's calendar events
  async getUserCalendarEvents(userId, timeMin, timeMax) {
    try {
      await this.setUserCredentials(userId);

      const response = await this.calendar.events.list({
        calendarId: 'primary',
        timeMin: timeMin || new Date().toISOString(),
        timeMax: timeMax || new Date(Date.now() + (30 * 24 * 60 * 60 * 1000)).toISOString(), // 30 days
        maxResults: 100,
        singleEvents: true,
        orderBy: 'startTime'
      });

      return response.data.items || [];
    } catch (error) {
      console.error('Error fetching calendar events:', error);
      throw new Error('Failed to fetch calendar events');
    }
  }

  // Check for booking conflicts with existing calendar events
  async checkBookingConflicts(userId, eventDate, duration = 2) {
    try {
      const startTime = new Date(eventDate);
      const endTime = new Date(startTime.getTime() + (duration * 60 * 60 * 1000));

      const events = await this.getUserCalendarEvents(
        userId,
        startTime.toISOString(),
        endTime.toISOString()
      );

      const conflicts = events.filter(event => {
        if (!event.start || !event.end) return false;
        
        const eventStart = new Date(event.start.dateTime || event.start.date);
        const eventEnd = new Date(event.end.dateTime || event.end.date);
        
        // Check for overlap
        return (startTime < eventEnd && endTime > eventStart);
      });

      return {
        hasConflicts: conflicts.length > 0,
        conflicts: conflicts.map(event => ({
          id: event.id,
          summary: event.summary,
          start: event.start.dateTime || event.start.date,
          end: event.end.dateTime || event.end.date
        }))
      };
    } catch (error) {
      console.error('Error checking booking conflicts:', error);
      return { hasConflicts: false, conflicts: [] };
    }
  }

  // Get busy times for availability checking
  async getBusyTimes(userId, timeMin, timeMax) {
    try {
      await this.setUserCredentials(userId);

      const response = await this.calendar.freebusy.query({
        resource: {
          timeMin: timeMin || new Date().toISOString(),
          timeMax: timeMax || new Date(Date.now() + (7 * 24 * 60 * 60 * 1000)).toISOString(), // 7 days
          items: [{ id: 'primary' }]
        }
      });

      return response.data.calendars.primary.busy || [];
    } catch (error) {
      console.error('Error fetching busy times:', error);
      return [];
    }
  }

  // Sync all user bookings to calendar
  async syncAllBookingsToCalendar(userId) {
    try {
      const { data: bookings, error } = await supabase
        .from('bookings')
        .select('*')
        .eq('user_id', userId)
        .in('status', ['confirmed', 'pending'])
        .is('calendar_event_id', null);

      if (error) {
        throw new Error('Failed to fetch bookings for sync');
      }

      const results = [];
      for (const booking of bookings) {
        try {
          const event = await this.createBookingEvent(userId, booking);
          results.push({ bookingId: booking.id, success: true, eventId: event.id });
        } catch (error) {
          console.error(`Failed to sync booking ${booking.id}:`, error);
          results.push({ bookingId: booking.id, success: false, error: error.message });
        }
      }

      return results;
    } catch (error) {
      console.error('Error syncing bookings to calendar:', error);
      throw new Error('Failed to sync bookings to calendar');
    }
  }

  // Remove calendar authorization
  async revokeCalendarAccess(userId) {
    try {
      const tokens = await this.getUserTokens(userId);
      if (tokens && tokens.access_token) {
        await this.oauth2Client.revokeToken(tokens.access_token);
      }

      // Remove tokens from database
      await supabase
        .from('user_calendar_tokens')
        .delete()
        .eq('user_id', userId);

      return true;
    } catch (error) {
      console.error('Error revoking calendar access:', error);
      throw new Error('Failed to revoke calendar access');
    }
  }

  // Get calendar integration status
  async getCalendarStatus(userId) {
    try {
      const tokens = await this.getUserTokens(userId);
      
      if (!tokens) {
        return { connected: false, lastSync: null };
      }

      // Check if tokens are still valid
      try {
        await this.setUserCredentials(userId);
        
        // Test API call
        await this.calendar.calendarList.get({ calendarId: 'primary' });
        
        return {
          connected: true,
          lastSync: tokens.updated_at,
          email: tokens.email || null
        };
      } catch (error) {
        return { connected: false, error: 'Invalid credentials' };
      }
    } catch (error) {
      console.error('Error checking calendar status:', error);
      return { connected: false, error: error.message };
    }
  }
}

module.exports = new CalendarService();